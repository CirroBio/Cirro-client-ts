/* tslint:disable */
/* eslint-disable */
/**
 * Cirro Data
 * Cirro Data Platform service API
 *
 * The version of the OpenAPI document: latest
 * Contact: support@cirro.bio
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CostResponse,
  CreateResponse,
  GetExecutionLogsResponse,
  RunAnalysisRequest,
  StopExecutionResponse,
  Task,
} from '../models/index';
import {
    CostResponseFromJSON,
    CostResponseToJSON,
    CreateResponseFromJSON,
    CreateResponseToJSON,
    GetExecutionLogsResponseFromJSON,
    GetExecutionLogsResponseToJSON,
    RunAnalysisRequestFromJSON,
    RunAnalysisRequestToJSON,
    StopExecutionResponseFromJSON,
    StopExecutionResponseToJSON,
    TaskFromJSON,
    TaskToJSON,
} from '../models/index';

export interface CalculateCostRequest {
    projectId: string;
    datasetId: string;
}

export interface GetExecutionLogsRequest {
    datasetId: string;
    projectId: string;
    forceLive?: boolean;
}

export interface GetProjectSummaryRequest {
    projectId: string;
    numberOfDays?: number;
}

export interface GetTaskLogsRequest {
    datasetId: string;
    projectId: string;
    taskId: string;
    forceLive?: boolean;
}

export interface GetTasksForExecutionRequest {
    datasetId: string;
    projectId: string;
    forceLive?: boolean;
}

export interface RunAnalysisOperationRequest {
    projectId: string;
    runAnalysisRequest: RunAnalysisRequest;
}

export interface StopAnalysisRequest {
    datasetId: string;
    projectId: string;
}

/**
 * 
 */
export class ExecutionApi extends runtime.BaseAPI {

    /**
     * Calculate cost of an execution run
     * Calculate cost
     */
    async calculateCostRaw(requestParameters: CalculateCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CostResponse>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling calculateCost.');
        }

        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling calculateCost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectId}/execution/{datasetId}/cost`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"datasetId"}}`, encodeURIComponent(String(requestParameters.datasetId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CostResponseFromJSON(jsonValue));
    }

    /**
     * Calculate cost of an execution run
     * Calculate cost
     */
    async calculateCost(requestParameters: CalculateCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CostResponse> {
        const response = await this.calculateCostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets live logs from main execution task
     * Get execution logs
     */
    async getExecutionLogsRaw(requestParameters: GetExecutionLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExecutionLogsResponse>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling getExecutionLogs.');
        }

        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getExecutionLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.forceLive !== undefined) {
            queryParameters['forceLive'] = requestParameters.forceLive;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectId}/execution/{datasetId}/logs`.replace(`{${"datasetId"}}`, encodeURIComponent(String(requestParameters.datasetId))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetExecutionLogsResponseFromJSON(jsonValue));
    }

    /**
     * Gets live logs from main execution task
     * Get execution logs
     */
    async getExecutionLogs(requestParameters: GetExecutionLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExecutionLogsResponse> {
        const response = await this.getExecutionLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets an overview of the executions currently running in the project
     * Get execution summary
     */
    async getProjectSummaryRaw(requestParameters: GetProjectSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<Task>; }>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getProjectSummary.');
        }

        const queryParameters: any = {};

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectId}/execution`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Gets an overview of the executions currently running in the project
     * Get execution summary
     */
    async getProjectSummary(requestParameters: GetProjectSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<Task>; }> {
        const response = await this.getProjectSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the log output from an individual task
     * Get task logs
     */
    async getTaskLogsRaw(requestParameters: GetTaskLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExecutionLogsResponse>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling getTaskLogs.');
        }

        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getTaskLogs.');
        }

        if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
            throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling getTaskLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.forceLive !== undefined) {
            queryParameters['forceLive'] = requestParameters.forceLive;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectId}/execution/{datasetId}/tasks/{taskId}/logs`.replace(`{${"datasetId"}}`, encodeURIComponent(String(requestParameters.datasetId))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters.taskId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetExecutionLogsResponseFromJSON(jsonValue));
    }

    /**
     * Gets the log output from an individual task
     * Get task logs
     */
    async getTaskLogs(requestParameters: GetTaskLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExecutionLogsResponse> {
        const response = await this.getTaskLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the tasks submitted by the workflow execution
     * Get execution tasks
     */
    async getTasksForExecutionRaw(requestParameters: GetTasksForExecutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Task>>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling getTasksForExecution.');
        }

        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getTasksForExecution.');
        }

        const queryParameters: any = {};

        if (requestParameters.forceLive !== undefined) {
            queryParameters['forceLive'] = requestParameters.forceLive;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectId}/execution/{datasetId}/tasks`.replace(`{${"datasetId"}}`, encodeURIComponent(String(requestParameters.datasetId))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskFromJSON));
    }

    /**
     * Gets the tasks submitted by the workflow execution
     * Get execution tasks
     */
    async getTasksForExecution(requestParameters: GetTasksForExecutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Task>> {
        const response = await this.getTasksForExecutionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Run analysis
     * Run analysis
     */
    async runAnalysisRaw(requestParameters: RunAnalysisOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateResponse>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling runAnalysis.');
        }

        if (requestParameters.runAnalysisRequest === null || requestParameters.runAnalysisRequest === undefined) {
            throw new runtime.RequiredError('runAnalysisRequest','Required parameter requestParameters.runAnalysisRequest was null or undefined when calling runAnalysis.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectId}/execution`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RunAnalysisRequestToJSON(requestParameters.runAnalysisRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateResponseFromJSON(jsonValue));
    }

    /**
     * Run analysis
     * Run analysis
     */
    async runAnalysis(requestParameters: RunAnalysisOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateResponse> {
        const response = await this.runAnalysisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Terminates all analysis jobs related to this execution
     * Stop execution
     */
    async stopAnalysisRaw(requestParameters: StopAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopExecutionResponse>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling stopAnalysis.');
        }

        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling stopAnalysis.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectId}/execution/{datasetId}/stop`.replace(`{${"datasetId"}}`, encodeURIComponent(String(requestParameters.datasetId))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StopExecutionResponseFromJSON(jsonValue));
    }

    /**
     * Terminates all analysis jobs related to this execution
     * Stop execution
     */
    async stopAnalysis(requestParameters: StopAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopExecutionResponse> {
        const response = await this.stopAnalysisRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
