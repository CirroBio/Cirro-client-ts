/* tslint:disable */
/* eslint-disable */
/**
 * Cirro Data
 * Cirro Data Platform service API
 *
 * The version of the OpenAPI document: latest
 * Contact: support@cirro.bio
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Discussion,
  DiscussionInput,
  EntityType,
  MessageInput,
  PaginatedResponseDiscussion,
  PaginatedResponseMessage,
  SortOrder,
} from '../models/index';
import {
    DiscussionFromJSON,
    DiscussionToJSON,
    DiscussionInputFromJSON,
    DiscussionInputToJSON,
    EntityTypeFromJSON,
    EntityTypeToJSON,
    MessageInputFromJSON,
    MessageInputToJSON,
    PaginatedResponseDiscussionFromJSON,
    PaginatedResponseDiscussionToJSON,
    PaginatedResponseMessageFromJSON,
    PaginatedResponseMessageToJSON,
    SortOrderFromJSON,
    SortOrderToJSON,
} from '../models/index';

export interface CreateDiscussionRequest {
    discussionInput: DiscussionInput;
}

export interface DeleteDiscussionRequest {
    discussionId: string;
}

export interface DeleteMessageRequest {
    discussionId: string;
    messageId: string;
}

export interface GetDiscussionRequest {
    discussionId: string;
}

export interface GetDiscussionsForEntityRequest {
    entityType: EntityType;
    entityId: string;
    nextToken?: string | null;
    limit?: number;
    order?: SortOrder | null;
}

export interface GetMessagesForDiscussionRequest {
    discussionId: string;
    nextToken?: string | null;
    limit?: number;
    threadId?: string | null;
    order?: SortOrder | null;
}

export interface PostMessageRequest {
    discussionId: string;
    messageInput: MessageInput;
}

export interface UpdateDiscussionRequest {
    discussionId: string;
    discussionInput: DiscussionInput;
}

export interface UpdateMessageRequest {
    discussionId: string;
    messageId: string;
    messageInput: MessageInput;
}

/**
 * 
 */
export class FeedApi extends runtime.BaseAPI {

    /**
     * Creates a new discussion for an entity
     * Create a discussion
     */
    async createDiscussionRaw(requestParameters: CreateDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Discussion>> {
        if (requestParameters.discussionInput === null || requestParameters.discussionInput === undefined) {
            throw new runtime.RequiredError('discussionInput','Required parameter requestParameters.discussionInput was null or undefined when calling createDiscussion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DiscussionInputToJSON(requestParameters.discussionInput),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DiscussionFromJSON(jsonValue));
    }

    /**
     * Creates a new discussion for an entity
     * Create a discussion
     */
    async createDiscussion(requestParameters: CreateDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Discussion> {
        const response = await this.createDiscussionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes an existing discussion and all associated messages
     * Delete a discussion
     */
    async deleteDiscussionRaw(requestParameters: DeleteDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.discussionId === null || requestParameters.discussionId === undefined) {
            throw new runtime.RequiredError('discussionId','Required parameter requestParameters.discussionId was null or undefined when calling deleteDiscussion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions/{discussionId}`.replace(`{${"discussionId"}}`, encodeURIComponent(String(requestParameters.discussionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes an existing discussion and all associated messages
     * Delete a discussion
     */
    async deleteDiscussion(requestParameters: DeleteDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDiscussionRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a message from a discussion
     * Delete a message
     */
    async deleteMessageRaw(requestParameters: DeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.discussionId === null || requestParameters.discussionId === undefined) {
            throw new runtime.RequiredError('discussionId','Required parameter requestParameters.discussionId was null or undefined when calling deleteMessage.');
        }

        if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
            throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling deleteMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions/{discussionId}/messages/{messageId}`.replace(`{${"discussionId"}}`, encodeURIComponent(String(requestParameters.discussionId))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters.messageId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a message from a discussion
     * Delete a message
     */
    async deleteMessage(requestParameters: DeleteMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMessageRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves a discussion by its ID
     * Get a discussion
     */
    async getDiscussionRaw(requestParameters: GetDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Discussion>> {
        if (requestParameters.discussionId === null || requestParameters.discussionId === undefined) {
            throw new runtime.RequiredError('discussionId','Required parameter requestParameters.discussionId was null or undefined when calling getDiscussion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions/{discussionId}`.replace(`{${"discussionId"}}`, encodeURIComponent(String(requestParameters.discussionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DiscussionFromJSON(jsonValue));
    }

    /**
     * Retrieves a discussion by its ID
     * Get a discussion
     */
    async getDiscussion(requestParameters: GetDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Discussion> {
        const response = await this.getDiscussionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a paginated list of discussions for a specific entity type and ID
     * Get discussions for an entity
     */
    async getDiscussionsForEntityRaw(requestParameters: GetDiscussionsForEntityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseDiscussion>> {
        if (requestParameters.entityType === null || requestParameters.entityType === undefined) {
            throw new runtime.RequiredError('entityType','Required parameter requestParameters.entityType was null or undefined when calling getDiscussionsForEntity.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling getDiscussionsForEntity.');
        }

        const queryParameters: any = {};

        if (requestParameters.entityType !== undefined) {
            queryParameters['entityType'] = requestParameters.entityType;
        }

        if (requestParameters.entityId !== undefined) {
            queryParameters['entityId'] = requestParameters.entityId;
        }

        if (requestParameters.nextToken !== undefined) {
            queryParameters['nextToken'] = requestParameters.nextToken;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedResponseDiscussionFromJSON(jsonValue));
    }

    /**
     * Retrieves a paginated list of discussions for a specific entity type and ID
     * Get discussions for an entity
     */
    async getDiscussionsForEntity(requestParameters: GetDiscussionsForEntityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseDiscussion> {
        const response = await this.getDiscussionsForEntityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all messages associated with a specific discussion
     * Get messages for a discussion
     */
    async getMessagesForDiscussionRaw(requestParameters: GetMessagesForDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseMessage>> {
        if (requestParameters.discussionId === null || requestParameters.discussionId === undefined) {
            throw new runtime.RequiredError('discussionId','Required parameter requestParameters.discussionId was null or undefined when calling getMessagesForDiscussion.');
        }

        const queryParameters: any = {};

        if (requestParameters.nextToken !== undefined) {
            queryParameters['nextToken'] = requestParameters.nextToken;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.threadId !== undefined) {
            queryParameters['threadId'] = requestParameters.threadId;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions/{discussionId}/messages`.replace(`{${"discussionId"}}`, encodeURIComponent(String(requestParameters.discussionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedResponseMessageFromJSON(jsonValue));
    }

    /**
     * Retrieves all messages associated with a specific discussion
     * Get messages for a discussion
     */
    async getMessagesForDiscussion(requestParameters: GetMessagesForDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseMessage> {
        const response = await this.getMessagesForDiscussionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Posts a new message to a discussion
     * Post a message
     */
    async postMessageRaw(requestParameters: PostMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.discussionId === null || requestParameters.discussionId === undefined) {
            throw new runtime.RequiredError('discussionId','Required parameter requestParameters.discussionId was null or undefined when calling postMessage.');
        }

        if (requestParameters.messageInput === null || requestParameters.messageInput === undefined) {
            throw new runtime.RequiredError('messageInput','Required parameter requestParameters.messageInput was null or undefined when calling postMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions/{discussionId}/messages`.replace(`{${"discussionId"}}`, encodeURIComponent(String(requestParameters.discussionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MessageInputToJSON(requestParameters.messageInput),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Posts a new message to a discussion
     * Post a message
     */
    async postMessage(requestParameters: PostMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postMessageRaw(requestParameters, initOverrides);
    }

    /**
     * Updates an existing discussion with new details
     * Update a discussion
     */
    async updateDiscussionRaw(requestParameters: UpdateDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.discussionId === null || requestParameters.discussionId === undefined) {
            throw new runtime.RequiredError('discussionId','Required parameter requestParameters.discussionId was null or undefined when calling updateDiscussion.');
        }

        if (requestParameters.discussionInput === null || requestParameters.discussionInput === undefined) {
            throw new runtime.RequiredError('discussionInput','Required parameter requestParameters.discussionInput was null or undefined when calling updateDiscussion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions/{discussionId}`.replace(`{${"discussionId"}}`, encodeURIComponent(String(requestParameters.discussionId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DiscussionInputToJSON(requestParameters.discussionInput),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing discussion with new details
     * Update a discussion
     */
    async updateDiscussion(requestParameters: UpdateDiscussionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateDiscussionRaw(requestParameters, initOverrides);
    }

    /**
     * Updates an existing message in a discussion
     * Update a message
     */
    async updateMessageRaw(requestParameters: UpdateMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.discussionId === null || requestParameters.discussionId === undefined) {
            throw new runtime.RequiredError('discussionId','Required parameter requestParameters.discussionId was null or undefined when calling updateMessage.');
        }

        if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
            throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling updateMessage.');
        }

        if (requestParameters.messageInput === null || requestParameters.messageInput === undefined) {
            throw new runtime.RequiredError('messageInput','Required parameter requestParameters.messageInput was null or undefined when calling updateMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("accessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/discussions/{discussionId}/messages/{messageId}`.replace(`{${"discussionId"}}`, encodeURIComponent(String(requestParameters.discussionId))).replace(`{${"messageId"}}`, encodeURIComponent(String(requestParameters.messageId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MessageInputToJSON(requestParameters.messageInput),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing message in a discussion
     * Update a message
     */
    async updateMessage(requestParameters: UpdateMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateMessageRaw(requestParameters, initOverrides);
    }

}
